/*
 * Copyright (c) 2014 Brocade Communications Systems others. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

module onf-ttp {
  /* Notes:
   *  => Comments that start with "SPEC:" are feedback for the ONF
   *  => Comments that start with "REFINE:" are notes for where we could enhance things
   *  => Comments that start with "TODO:" are places where we *need* to do work
   */

  namespace "urn:onf:ttp";
  prefix ttp;

  import openflow-extensible-match {prefix oxm;}
  //import openflow-instruction {prefix ofi;}
  import openflow-types {prefix oft;}

  revision 2014-07-11 {
    description "ONF TTP schema 2014/07/11";
  }

  grouping name-property {
    description "denotes something that has a name, which is a string";

    leaf name {
      type string;
    }
  }

  grouping opt-tag-property {
    description "denotes strings that represent optional functionality in the TTP";

    leaf opt-tag {
      type string;
    }
  }

  grouping doc-property {
    description "denotes something that has documentation as a list of strings";

    leaf-list doc {
      type string;
    }
  }

  grouping universal-TTP-properties {
    //SPEC: exactly what can have have these?
    description "these properties are applicable to all objects in TTPs";

    uses name-property;
    uses opt-tag-property;
    uses doc-property;
  }


  grouping type-property {
    description "denotes something that has a type identified with a string";

    leaf type {
      type string;
    }
  }

  grouping NDM_metadata-properties {
    description "metadata about an NDM (or TTP)";

    leaf authority {
       type string;
    }

    leaf OF_protocol_version {
       type string;
    }

    leaf version {
       type string;
    }

    uses type-property;
    uses universal-TTP-properties;
  }

  grouping table-type-pattern-properties {
    container NDM_metadata {
      uses NDM_metadata-properties;
    }

    list identifiers {
      uses universal-TTP-properties;
      leaf var {
        type string;
      }
      leaf range {
        //REFINE: we can add a regex patter to restrict this
        //REFINE: also make sure range in YANG doesn't do this
        type string;
      }

      //TODO: figure out how/if we want to include extensions
      //SPEC: need an example for how an extension will be specified

      //SPEC: should be clearer about Varibles vs. Identifiers
    }

    list features {
      uses universal-TTP-properties;
      leaf feature {
        type string;
        //REFINE: can we restrict this more than just a string?
      }
    }

    list table_map { // intentionally not using the "univ TTP props"
      key name;
      leaf name {
        type string;
      }
      leaf number {
        type uint8;
      }
      //SPEC: you can't do what is there in YANG, maybe put name in the tables in flow_tables?
    }

    container meter_table {
      uses universal-TTP-properties;
      list meter_types {
        uses universal-TTP-properties;
        list bands {
          uses universal-TTP-properties;
          leaf type {
            type enumeration {
              enum DROP;
              enum DSCP_REMARK;
            }
          }
          leaf rate {
            type string;
            //REFINE: use a regex patter?
            //SPEC: make min and max as ints?
          }
          leaf burst {
            type string;
            //REFINE: use a regex patter?
            //SPEC: make min and max as ints?
          }
        }
      }
      list built_in_meters {
        uses universal-TTP-properties;
        leaf meter_id {
          type uint32; //borrowed from OF spec
        }
        leaf rate {
          type uint32;
          //REFINE: right int?
        }
        leaf burst {
          type uint32;
          //REFINE: right int?
        }
      }
    }

    list flow_tables {
      //TODO: can inner types also have the univ TTP properties?
      uses universal-TTP-properties;
      list flow_mod_types {
        uses universal-TTP-properties;
        leaf priority {  // priority or priority rank allowed
                         // must have one, not 0 or >1... how to express?
                         // if one flow_mod has priority, all must have?
                         // if one flow_mod has priority_rank, all must have?
                         // SPEC: how to schema the constraints on priority?
          type string; // can hold numbers or ranges... how to express?
                       // SPEC: describes as "integer"
                       // really is a string that can hold int or int range
        }
        leaf priority_rank {
          type string; // strings that represent numbers
                       // SPEC: priority ranks must be unique within flow table?
                       // SPEC: priority-rank is incompatible with built-in-flow-mods
                       // SPEC: That is, cannot be used in the same flow table (see below)
        }
        list match_set { // SPEC: mentions that pre-requisites are assumed even if not listed
                         // SPEC: this implies requirement that explicit pre-reqs that mismatch are illegal
          leaf field {
            type identityref {
              base oxm:match-field;
            }
          }
          leaf match_type { // was "wc_type" in older (pre-spec) TTP
            type enumeration {
              enum exact; // exact match, as if all mask bits = 1 (also default)
              enum mask;  // arbitrary mask field allowed for this field
                          // SPEC: is it clear what happens if no mask present? All 1's?
              enum prefix; // mask must be contiguous ones from MSB of field (like subnet mask)
              enum all_or_exact; // field may be omitted, but exact match if present
              //TODO: are there more? [Curt: these are all enums in match_type... DONE]
            }
          }
          leaf mask { // has 1's where must match. Presence and value must agree with match_type
            type string; // a string representing numbers (dec, hex, etc)
          }
          leaf value {
            type string; // either a variable name or fixed value for the field
                         // SPEC: how to express in schema that numbers are allowed, or var names from list
          }
          leaf const_mask { // mask for specifying value bits that cannot be varied
            type string;    // SPEC: would be good to have an example!
          }
          leaf const_value { // value used to specify the value of unvarying bits
                             // SPEC: seems like const_mask and const_value must come together?
                             // SPEC: const_mask and const_value invalid with "exact" or "all_or_exact"?
                             // SPEC: const_mask and const_value valid with mask...but prefix? Clarify
            type string;
          }
        }
        container instruction_set {  // why is inst_set a container, but match_set not?
          list exactly_one {
            list option { //TODO: this should be an anonymous list, but I don't know how
              leaf instruction {
                type identityref {
                  base oft:instruction-base;
                }
              }
              //TODO: need a leaf for the conditional instruction parameters
            }
          }
        }
      }
      list built_in_flow_mods { // SPEC: says "usually are flow_mods that ..."  Usually? Always?
                             // built-ins are flow_mods, not just templates like flow_mod_types
                             // so the allowed fields are similar
                             // can we leverage similarity, or do we need to repeat the fields?
                             // as flow-mod-types get more complex, leverage is important
        uses universal-TTP-properties;
        leaf priority { // SPEC: Only "priority" allowed for built-ins? (rank doesn't work?)
                        // SPEC: (rank doesn't work because implies "specified later")
                        // SPEC: if built-in and flow-mod-types are defined for same table...
                        // SPEC: and if "priority" is required for built-in, then...
                        // SPEC: then flow-mod-types in same table must be "priority" (not rank)
          type string; // can hold numbers or ranges... how to express?
        }
        list match_set { // SPEC: mentions that pre-requisites are assumed even if not listed
                         // SPEC: this implies requirement that explicit pre-reqs that mismatch are illegal
          leaf field {
            type identityref {
              base oxm:match-field;
            }
          }
          // SPEC: for built-in flow mods, these are not templates (constraints), but actual flow mods
          // SPEC: for flow mod, match type is expressed, not described...
          // SPEC: as such, "match_type" seems pointless?  Or maybe "prefix"
          // SPEC: const_value and const_mask meaningless
          leaf mask { // has 1's where must match.
            type string; // a string representing numbers (dec, hex, etc)
          }
          leaf value { // SPEC: for built-in flow mod, this is required, must be a number
            type string;
          }
        }
        container instruction_set {  // why is inst_set a container, but match_set not?
          list exactly_one {
            list option { //TODO: this should be an anonymous list, but I don't know how
              leaf instruction {
                type identityref {
                  base oft:instruction-base;
                }
              }
              //TODO: need a leaf for the conditional instruction parameters
            }
          }
        }
      }
      list table_subsets {
        uses universal-TTP-properties; // "name" is a required field, used as alias
        list subset {
           anon string;  // unnamed list of strings that must be names of flow-mod-types in table
        }
      }
    }

    list group_entry_types {
      uses universal-TTP-properties;
      //TODO: model
    }

    list packet_out {
      uses universal-TTP-properties;
      //TODO: model
    }

    list parameters {
      uses universal-TTP-properties;
      uses type-property;
      leaf default {
        type union {
          type string;
          type uint32;
          //TODO: is this sufficient?
          //SPEC: this seems ambiguous in the spec
        }
      }
    }

    list flow_paths {
      uses universal-TTP-properties;
      leaf-list path {
        description "a list of strings each of which must be the name of a
                     table from the table_map or the name of a table in square
                     brackets.";
        type string;
        //SPEC: rework, can't have this in YANG
        // We wanted: "flow_paths": ["path": ["table1", ["table2"] ] ]
        // We did: "flow_paths": ["path": ["table1", "[table2]" ] ]
      }
      leaf-list no-path {
        description "a list of strings each of which must be the name of a
                     table from the table_map or the name of a table in square
                     brackets.";
        type string;
      }
      //REFINE: this is really either path or no-path. can we do better in modeling?
      //SPEC: could be clearer about whether you can mix path and no-path and if so, what happens.
    }

    container security {
      uses universal-TTP-properties;
    }
  }

  container opendaylight-ttps {
    container table-type-patterns {
      list table-type-pattern {
        uses table-type-pattern-properties;
      }
    }
    description "The global TTP registry for OpenDaylight";
  }
}
